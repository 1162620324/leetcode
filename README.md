# leetcode-
LeetCode刷题经历
2019-4-24， 第31题，下一个全排列：
    
    这一题主要考察全排列的性质，考察观察到位，可以发现，一个全排列的下一个全排列必然有着尽可能多的前缀，也就是说，一个全排列从后往前看，第一个出现不满足
    降序排列的那个数字x，应该和后面降序中最小的大于x的数字进行交换，交换完成后，再后面的数字进行升序排列，得到的结果就是下一个全排列。注意，全排列的产生，
    是尽可能先取小的数字放在高位，然后如果不满足，先从低位开始交换。


2019-4-25,  第21题，合并两个链表

    由于听说机试大多使用C，所以从今天开始均使用C完成题目
    21题是个easy题，相当于给自己熟悉一下C，因为好久没用了，这次出现的问题，是因为在使用结构体的时候，循环中申请需要动态申请，否则始终指向的是同一个结构体
    变量

2020-3-17，第36题，

    重启leetcode项目了hhhh,过去一年里算法碰的少了，写的代码也大多数是模型，所以打算重新做下leetcode锻炼一下自己的思路以及coding能力。也算是提前为面试做准备吧。
    这一题本来可以按照遍历的思路吧，但是为了减少对board的遍历次数，所以就想办法一遍遍历就能判断所有的列行小正方形是否有重合，办法就是相当于提前建立一个字典吧。巧妙利用索引，判断是否在第i行第j列中出现过，至于小正方形的话，对索引除以3取商就行了（//），如果出现过了，就代表重复，直接返回false.
    这里有个有趣的地方，就是发现python的list有个骚操作，竟然可以直接加（网上找了答案，思路和我一样，但代码比我简洁）
    另外，运行的时候至于判断是否出现过的容器我试了list和dict,结果dict用的内存更少，没想到的，因吹斯听。
    over

2020-3-18， 第18题
    

    这一题相当于3sum的升级版吧，利用递归的思想把4转换为3，首先进行排序，然后从小到大，依次考虑，可以理解为，先假设结果包含第一个数，那么就找剩余的3个数使得其满足和等于target-num[1],因此就把问题降维，另外，在剩下的问题考虑当中，就不用考虑这第一个数了，因为这里已经考虑了所有包含第一个数的情况了。
    换言之，k数之和也完全可以利用赌鬼的思想转换为k-1个数的和。

### **2021-01-11** 

开始为找工作做准备，每天固定leetcode五道题，不得延误，加油！！！

151. Reverse words in a string

     ![1610353247828](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1610353247828.png)

这道题让我们把一个字符串按照单词进行逆序，比如“I am your father”->"father your an I"，但是单词的内部不逆序，需要注意的是空格的处理，输入的字符串可能首位中间有不定个数的字符串，但输出要求首尾无字符串，单词之间只有一个字符串。

首先简单的做法是按照顺序忽略空格取出每个单词，然后添加至vector，最后再连起来，显然这种做法时间耗费都较多。

在查了网上大神做法后，只对输入s原址操作，做法是先将整个字符串逆序，然后再对每个单词再逆序，用一个辅助变量storeIndex记录新字符串更改到的位置，同时忽略空格，将单词前移空格个数的位置。

152. Maximum Product Subarray

     ![1610353812189](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1610353812189.png)

这道题个人觉得蛮难，一开始实在想不到怎么用DP，后来找到了答案，也想了半天，因为是乘积，所以最小的是负数接下来乘一个负数，就可能立马变成最大的。所以不仅要维护当前最大的，还要维护当前最小的。用两个DP数组f[i],g[i]记录[0, i]范围内包含nums[i]的最大连续子数组乘积和最小连续子数组乘积。

153. Find minimun in rotated sorted array

     ![1610355026647](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1610355026647.png)

这道题起初我没有读懂题目的意思，直接遍历的找到畸变的点。实际上应该采用二分，154道题也是这样不再赘述

154. Find minimun in rotated sorted array II

215. Kth Largest Element in an Array

     ![1610355157059](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1610355157059.png)

这道题最简便的想法便是先排序了，但排序本身复杂度就是O(nlogn)，可以借鉴快排的partition，取出一个pivot，比他大的放左边，小的放右边，这样左边个数是k-1的时候，这个pivot就是要找的第k大的数，否则就进行递归。